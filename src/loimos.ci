// Copyright 2020-2023 The Loimos Project Developers.
// See the top-level LICENSE file for details.
//
// SPDX-License-Identifier: MIT

mainmodule loimos {
  include "Interaction.h";
  include "Message.h";
  include "intervention_model/Interventions.h";

  #ifdef USE_HYPERCOMM
  include "AggregatorParam.h";
  #endif // USE_HYPERCOMM

  // Profiling/LB parameters (these are here because Defs.h depends on having
  // CBase_* classes defined, and these constants are only used in this file)
  #define PROFILING_START_DAY DAYS_IN_WEEK
  #define PROFILING_INTERVAL 3
  #define SHOULD_PROFILE(day) (day >= PROFILING_START_DAY &&\
    (day - PROFILING_START_DAY) % PROFILING_INTERVAL == 0)

  #define LB_START_DAY 6
  #define LB_INTERVAL DAYS_IN_WEEK
  #define SHOULD_LB(day) (day >= LB_START_DAY &&\
    (day - LB_START_DAY) % LB_INTERVAL == 0)

  include "functional";
  include "string";
  include "vector";
  include "memory";
  include "sys/time.h";
  include "sys/resource.h";

  readonly CProxy_Main mainProxy;
  readonly CProxy_People peopleArray;
  readonly CProxy_Locations locationsArray;
  #ifdef USE_HYPERCOMM
  readonly CProxy_Aggregator aggregatorProxy;
  #endif // USE_HYPERCOMM
  readonly CProxy_DiseaseModel globDiseaseModel;
  readonly CProxy_TraceSwitcher traceArray;
  readonly int numPeople;
  readonly int numLocations;
  readonly int numPeoplePartitions;
  readonly int numLocationPartitions;
  readonly int numDays;
  readonly int numDaysWithRealData;

  readonly std::vector<double> attrInput;

  readonly bool syntheticRun;
  readonly int contactModelType;
  readonly int firstPersonIdx;
  readonly int firstLocationIdx;

  readonly uint64_t totalVisits;
  readonly double simulationStartTime;
  readonly double iterationStartTime;
  readonly double stepStartTime;
  readonly std::vector<double> totalTime;

  #define TOTAL_TIME_INDEX 0
  #define TOTAL_VISITS_TIME_INDEX 1
  #define TOTAL_INTERACTIONS_TIME_INDEX 2
  #define TOTAL_EOD_UPDATE_TIME_INDEX 3
  #define TOTAL_TIME_SIZE 4

  readonly int synPeopleGridWidth;
  readonly int synPeopleGridHeight;
  readonly int synLocationGridWidth;
  readonly int synLocationGridHeight;
  readonly int synLocalLocationGridWidth;
  readonly int synLocalLocationGridHeight;
  readonly int synLocationPartitionGridWidth;
  readonly int synLocationPartitionGridHeight;
  readonly int averageDegreeOfVisit;

  readonly bool interventionStategy;

  PUPable Intervention;
  PUPable VaccinationIntervention;

  mainchare Main {
    entry Main(CkArgMsg*);
    entry [reductiontarget] void CharesCreated();
    entry void run() {
      // We only want to collect instumentation on the main loop
      #ifdef ENABLE_LB
        serial{traceArray.instrumentOn();}
        when instrumentSwitchOn() {}
      #endif // ENABLE_LB

      serial{
        totalTime.resize(TOTAL_TIME_SIZE, 0);
        CkPrintf("Running ...\n\n");
        simulationStartTime = CkWallTimer();
      }

      for(day = 0; day < numDays; day++) {
        //serial{CkPrintf("  Starting iteration\n");}
        #ifdef ENABLE_TRACING
          if (SHOULD_PROFILE(day)){
            serial{traceArray.traceOn();}
            when traceSwitchOn() {}
          }
        #endif
        serial {
          //auto cbfunction = [] (int i) -> int { return i ** 2; };
          //FunctionMessage funcMessage(cbfunction);
          //peopleArray[0].TestCall(cbfunction);
          iterationStartTime = CkWallTimer();

          //CkPrintf("  Sending Visit Messages\n");
          // try adding fflush
          stepStartTime = CkWallTimer();
          peopleArray.SendVisitMessages();
          CkStartQD(CkCallback(
            CkIndex_Main::StartComputingInteractions(),
            mainProxy
          ));
        }
        when StartComputingInteractions() {
          serial {
            double diff = CkWallTimer() - stepStartTime;
            CkPrintf("  Visit messages took %fs\n",
              diff);
            totalTime[TOTAL_VISITS_TIME_INDEX] += diff;

            //CkPrintf("  Compute Interactions\n");
            stepStartTime = CkWallTimer();
            locationsArray.ComputeInteractions();
            if (DAYS_TO_SEED_INFECTION > day) {
              SeedInfections();
            }

            CkStartQD(CkCallback(
              CkIndex_Main::ComputedInteractions(),
              mainProxy
            ));
          }
        }
        when ComputedInteractions() {
          serial {
            double diff = CkWallTimer() - stepStartTime;
            CkPrintf("  Interaction messages took %fs\n",
              diff);
            totalTime[TOTAL_INTERACTIONS_TIME_INDEX] += diff;

            //CkPrintf("  End of day state update starting\n");
            stepStartTime = CkWallTimer();
            peopleArray.EndOfDayStateUpdate();
          }
        }
        when ReceiveInfectiousCount(int infectiousCount) {
          serial {
            double diff = CkWallTimer() - stepStartTime;
            CkPrintf("  End of day state update and reduction took %fs\n",
              diff);
            totalTime[TOTAL_EOD_UPDATE_TIME_INDEX] += diff;

            // Use this count as desired here
            if (interventionStategy) {
              globDiseaseModel.applyInterventions(day, infectiousCount);
            }

            // Print how long this iteration took to run
            CkPrintf(
              "Iteration %d Execution Time: %lf seconds. Infectious Count: %d.\n",
              day, CkWallTimer() - iterationStartTime, infectiousCount
            );
          }
        }

        #ifdef ENABLE_LB
          // Turn off instrumentation before we start load balancing
          serial{traceArray.instrumentOff();}
          when instrumentSwitchOff() {}

          if (SHOULD_LB(day)) {
            serial {
              locationsArray.AtSync();
              peopleArray.AtSync();
            }

            // We don't want to continue until load balancing is complete for
            // *both* locations and people chares
            when locationsLBComplete() {
              when peopleLBComplete() {}
            }
          }
        #endif // ENABLE_LB


        #ifdef ENABLE_TRACING
          if (SHOULD_PROFILE(day)) {
            serial{traceArray.traceOff();}
            when traceSwitchOff(){
              serial{traceArray.traceFlush();}
            }

            // Toggled by ENABLE_TRACING to group profiling code
            serial{traceArray.reportMemoryUsage();}
            when printMemoryUsage(long usage) {
              serial {
                CkPrintf("Currently using %ld kb in total\n", usage);
              }
            }
          }

        #endif // ENABLE_TRACING
      }
      serial {
        CkPrintf("Finished simulating %d days in %lf seconds.\n", numDays, (CkWallTimer() - simulationStartTime));
        CkPrintf("  Visit messages took %lf seconds\n",
          totalTime[TOTAL_VISITS_TIME_INDEX]);
        CkPrintf("  Interaction calculations and messages took %lf seconds\n",
          totalTime[TOTAL_INTERACTIONS_TIME_INDEX]);
        CkPrintf("  End of day update and reduction took %lf seconds\n",
          totalTime[TOTAL_EOD_UPDATE_TIME_INDEX]);

        peopleArray.SendStats();
      }
      when ReceiveStats(CkReductionMsg *summary) {
        serial {
          int *data = reinterpret_cast<int *>(summary->getData());
          SaveStats(data);
        }
      }
      serial {
        CkExit();
      }
    };

    entry void SeedInfections();
    entry void StartComputingInteractions();
    entry void ComputedInteractions();
    #ifdef ENABLE_DEBUG
    entry [reductiontarget] void ReceiveVisitsCount(int visitsCount) {
        serial{CkPrintf("  Loaded a total of %d visits\n", visitsCount);}
    };
    #endif // ENABLE_DEBUG
    entry [reductiontarget] void ReceiveInfectiousCount(int infectiousCount);
    entry [reductiontarget] void ReceiveStats(CkReductionMsg *summary);
    #ifdef ENABLE_TRACING
    entry [reductiontarget] void traceSwitchOn();
    entry [reductiontarget] void traceSwitchOff();
    entry [reductiontarget] void printMemoryUsage(long usage);
    #endif // ENABLE_TRACING
    #ifdef ENABLE_LB
    entry [reductiontarget] void instrumentSwitchOn();
    entry [reductiontarget] void instrumentSwitchOff();
    entry [reductiontarget] void locationsLBComplete();
    entry [reductiontarget] void peopleLBComplete();
    #endif // ENABLE_LB
  };

  group TraceSwitcher{
    entry TraceSwitcher();
    #ifdef ENABLE_TRACING
    entry void traceOn();
    entry void traceOff();
    entry void traceFlush();
    entry void reportMemoryUsage();
    #endif // ENABLE_TRACING
    #ifdef ENABLE_LB
    entry void instrumentOn();
    entry void instrumentOff();
    #endif // ENABLE_LB
  };

  #ifdef USE_HYPERCOMM
  group Aggregator {
    entry Aggregator(AggregatorParam p1, AggregatorParam p2);
  };
  #endif // USE_HYPERCOMM

  array [1D] People {
    entry People(std::string scenarioPath);
    entry void SendVisitMessages(); // calls ReceiveVisitMessages
    entry void ReceiveInteractions(InteractionMessage);
    entry void EndOfDayStateUpdate(); // contribute call to ReceiveInfectiousCount
    entry void SendStats(); // contribute call to ReceiveStats
    entry void ReceiveIntervention(std::shared_ptr<Intervention>);
    //entry void TestCall(std::function<int(int)> func);
    entry void AtSync();
  };

  array [1D] Locations {
    entry Locations(std::string scenarioPath);
    entry void ReceiveVisitMessages(VisitMessage);
    entry void ComputeInteractions(); // calls ReceiveInteractions
    entry void AtSync();
  };

  nodegroup DiseaseModel {
      entry DiseaseModel(std::string pathToModel, std::string scenarioPath,
          std::string pathToIntervention);
      entry void applyInterventions(int day, int newDailyInfections);
  };

  #ifdef USE_HYPERCOMM
  namespace aggregation {
    initproc void initialize(void);
  }
  #endif // USE_HYPERCOMM
};
