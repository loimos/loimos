// Copyright 2020 The Loimos Project Developers.
// See the top-level LICENSE file for details.
//
// SPDX-License-Identifier: MIT

mainmodule loimos {
  include "Interaction.h";
  include "Message.h";
  
  // Profiling/LB parameters (these are here because Defs.h depends on having
  // CBase_* classes defined, and these constants are only used in this file)
  #define PROFILING_START_DAY DAYS_IN_WEEK
  #define PROFILING_INTERVAL 28
  #define LB_START_DAY 6
  #define LB_INTERVAL DAYS_IN_WEEK

  include "vector";
  include "sys/time.h";
  include "sys/resource.h";

  readonly CProxy_Main mainProxy;
  readonly CProxy_People peopleArray;
  readonly CProxy_Locations locationsArray;
  readonly CProxy_DiseaseModel globDiseaseModel;
  readonly CProxy_TraceSwitcher traceArray;
  readonly int numPeople;
  readonly int numLocations;
  readonly int numPeoplePartitions;
  readonly int numLocationPartitions;
  readonly int numDays;

  readonly bool syntheticRun;
  readonly int contactModelType;
  readonly int firstPersonIdx;
  readonly int firstLocationIdx;
  readonly std::string scenarioPath;
  readonly std::string scenarioId;

  readonly uint64_t totalVisits;
  readonly double simulationStartTime;
  readonly double iterationStartTime;

  readonly int synPeopleGridWidth;
  readonly int synPeopleGridHeight;
  readonly int synLocationGridWidth;
  readonly int synLocationGridHeight;
  readonly int synLocalLocationGridWidth;
  readonly int synLocalLocationGridHeight;
  readonly int synLocationPartitionGridWidth;
  readonly int synLocationPartitionGridHeight;
  readonly int averageDegreeOfVisit;

  mainchare Main {
    entry Main(CkArgMsg*);
    entry [reductiontarget, threaded] void ArraysCreated();
    entry void run() {
      // We only want to collect instumentation on the main loop
      #ifdef ENABLE_LB
        serial{traceArray.instrumentOn();}
        when instrumentSwitchOn() {}
      #endif // ENABLE_LB

      for(day = 0; day < numDays; day++) {
      #ifdef USE_PROJECTIONS
        if ((day - PROFILING_START_DAY) % PROFILING_INTERVAL == 0){
            serial{traceArray.traceOn();}
            when traceSwitchOn() {}
        }
      #endif
        serial {
          iterationStartTime = CkWallTimer();
          // CkPrintf("Sending Visit Messages\n");
          peopleArray.SendVisitMessages();
          // CkPrintf("QD Visit Messages\n");
          CkStartQD(CkCallback(
            CkIndex_Main::StartComputingInteractions(),
            mainProxy
          ));
        }
        when StartComputingInteractions() {
          serial {
            // CkPrintf("Compute Interactions\n");
            locationsArray.ComputeInteractions();
            // CkPrintf("QD Compute Interactions\n");
            
            CkStartQD(CkCallback(
              CkIndex_Main::ComputedInteractions(),
              mainProxy
            ));
          }
        }
        when ComputedInteractions() {
          serial {
            // CkPrintf("Reporting Stats\n");
            peopleArray.EndOfDayStateUpdate();
          }
        }
        when ReceiveInfectiousCount(int infectiousCount) {
          serial {
            // Use this count as desired here
            
            // Print how long this iteration took to run
            CkPrintf(
              "Iteration %d Execution Time: %lf seconds.\n",
              day, CkWallTimer() - iterationStartTime
            );
          }
        }

        #ifdef ENABLE_LB
          // Turn off instrumentation before we start load balancing
          serial{traceArray.instrumentOff();}
          when instrumentSwitchOff() {}
          
          if ((day - LB_START_DAY) % LB_INTERVAL == 0) {
            serial {
              locationsArray.AtSync();
              peopleArray.AtSync();
            }

            // We don't want to continue until load balancing is complete for
            // *both* locations and people chares
            when locationsLBComplete() {
              when peopleLBComplete() {}
            }
          }
        #endif // ENABLE_LB
      

        #ifdef USE_PROJECTIONS
          if ((day - PROFILING_START_DAY) % PROFILING_INTERVAL == 0) {
              serial{traceArray.traceOff();}
              when traceSwitchOff(){}
          }
          
          // Toggled by USE_PROJECTIONS to group profiling code
          serial{traceArray.reportMemoryUsage();}
          when printMemoryUsage(long usage) {
            serial {
              CkPrintf("Currently using %ld kb in total\n", usage);
            }
          }
        #endif // USE_PROJECTIONS
      }
      serial { 
        CkPrintf("\nFinished data loading in %lf seconds.\n", simulationStartTime);
        CkPrintf("Finished simulating %d days in %lf seconds.\n", numDays, (CkWallTimer() - simulationStartTime));
        
        peopleArray.SendStats();
      }
      when ReceiveStats(CkReductionMsg *summary) {
        serial {
          int *data = reinterpret_cast<int *>(summary->getData());
          SaveStats(data);
        }
      }
      serial {
        CkExit(); 
      }
    };
    entry void StartComputingInteractions(); 
    entry void ComputedInteractions();
    entry [reductiontarget] void ReceiveInfectiousCount(int infectiousCount);
    entry [reductiontarget] void ReceiveStats(CkReductionMsg *summary);
    #ifdef USE_PROJECTIONS
    entry [reductiontarget] void traceSwitchOn();
    entry [reductiontarget] void traceSwitchOff();
    entry [reductiontarget] void printMemoryUsage(long usage);
    #endif // USE_PROJECTIONS
    #ifdef ENABLE_LB
    entry [reductiontarget] void instrumentSwitchOn();
    entry [reductiontarget] void instrumentSwitchOff();
    entry [reductiontarget] void locationsLBComplete();
    entry [reductiontarget] void peopleLBComplete();
    #endif // ENABLE_LB
  };


  group TraceSwitcher{
    entry TraceSwitcher();
    #ifdef USE_PROJECTIONS
    entry void traceOn();
    entry void traceOff();
    entry void traceFlush();
    entry void reportMemoryUsage();
    #endif // USE_PROJECTIONS
    #ifdef ENABLE_LB
    entry void instrumentOn();
    entry void instrumentOff();
    #endif // ENABLE_LB
  };

  array [1D] People {
    entry People();
    entry void CreateAggregator(CkCallback cb);
    entry void SendVisitMessages(); // calls ReceiveVisitMessages
#ifdef USE_TRAM
    entry [aggregate] void ReceiveInteractions(InteractionMessage);
#else
    entry void ReceiveInteractions(InteractionMessage);
#endif
    entry void EndOfDayStateUpdate(); // contribute call to ReceiveInfectiousCount
    entry void SendStats(); // contribute call to ReceiveStats
    entry void AtSync();
  };

  array [1D] Locations {
    entry Locations();
#ifdef USE_TRAM
    entry [aggregate] void ReceiveVisitMessages(VisitMessage);
#else
    entry void ReceiveVisitMessages(VisitMessage);
#endif
    entry void ComputeInteractions(); // calls ReceiveInteractions
    entry void AtSync();
  };

  nodegroup DiseaseModel {
      entry DiseaseModel(std::string pathToModel, std::string scenarioPath);
  };

  namespace aggregation {
    initproc void initialize(void);
  }
};
