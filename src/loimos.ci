// Copyright 2020-2023 The Loimos Project Developers.
// See the top-level LICENSE file for details.
//
// SPDX-License-Identifier: MIT

mainmodule loimos {
  include "Defs.h";
  include "Types.h";
  include "Interaction.h";
  include "Message.h";
  include "readers/Parse.h";

#ifdef USE_HYPERCOMM
  include "AggregatorParam.h";
#endif // USE_HYPERCOMM

#ifdef ENABLE_AGGREGATION
  #define AGGREGATE [aggregate(numDimensions: 1)]
#else
  #define AGGREGATE
#endif

  // Profiling/LB parameters (these are here because Defs.h depends on having
  // CBase_* classes defined, and these constants are only used in this file)
  #define PROFILING_START_DAY 85
  #define PROFILING_END_DAY 87
  #define SHOULD_PROFILE (day >= PROFILING_START_DAY &&\
    day <= PROFILING_END_DAY)
  //#define PROFILING_INTERVAL 1
  //#define SHOULD_PROFILE(day) (day >= PROFILING_START_DAY &&\
  //  day <= PROFILING_END_DAY && \
  //  (day - PROFILING_START_DAY) % PROFILING_INTERVAL == 0)

  #define LB_START_DAY 6
  #define LB_INTERVAL 8
  #define SHOULD_LB(day) (day >= LB_START_DAY &&\
    (day - LB_START_DAY) % LB_INTERVAL == 0)

#ifdef USE_HYPERCOMM
  include "AggregatorParam.h";
#endif // USE_HYPERCOMM

  include "string";
  include "vector";
  include "memory";
  include "sys/time.h";
  include "sys/resource.h";

  readonly CProxy_Main mainProxy;
  readonly CProxy_People peopleArray;
  readonly CProxy_Locations locationsArray;
#ifdef USE_HYPERCOMM
  readonly CProxy_Aggregator aggregatorProxy;
#endif // USE_HYPERCOMM
  readonly CProxy_Scenario globScenario;
  readonly CProxy_TraceSwitcher traceArray;

  mainchare Main {
    entry Main(CkArgMsg*);
    entry [reductiontarget] void CharesCreated();
    entry void run() {
      // We only want to collect instumentation on the main loop
#ifdef ENABLE_LB
        serial{traceArray.instrumentOn();}
        when instrumentSwitchOn() {}
#endif // ENABLE_LB

      serial{
        CkPrintf("Running ...\n\n");
        profile.simulationStartTime = CkWallTimer();
        lastInfectiousCount = 0;
      }

      if (scenario->isOnTheFly()) {
        serial {
          peopleArray.SendVisitSchedules();
          CkStartQD(CkCallback(
            CkIndex_Main::StartupComplete(),
            mainProxy
          ));
        }

      } else {
        serial {
          locationsArray.SendExpectedVisitors();
          CkStartQD(CkCallback(
            CkIndex_Main::StartupComplete(),
            mainProxy
          ));
        }
      }

      when StartupComplete() {}

#ifdef ENABLE_FORCE_FULL_RUN
      for (day = 0; day < scenario->numDays; day++) {
#else
      // It's usually not helpful to keep running the simulation after the
      // outbreak has died out
      for (day = 0; day < scenario->numDays \
        && (day < scenario->numDaysToSeedOutbreak || 0 != lastInfectiousCount); day++) {
#endif  // ENABLE_FORCE_FULL_RUN
        // serial{CkPrintf("  Starting iteration\n");}
#ifdef ENABLE_TRACING
          if (day == PROFILING_START_DAY){
            serial{traceArray.traceOn();}
            when traceSwitchOn() {}
          }
#endif
        serial {
          profile.iterationStartTime = CkWallTimer();

          // CkPrintf("  Sending Visit Messages\n");
          profile.stepStartTime = CkWallTimer();
          peopleArray.SendVisitorStates();
          CkStartQD(CkCallback(
            CkIndex_Main::StartComputingInteractions(),
            mainProxy
          ));
        }
        when StartComputingInteractions() {
          serial {
            double diff = CkWallTimer() - profile.stepStartTime;
            CkPrintf("  Visit messages took %fs\n",
              diff);
            profile.visitsTime += diff;

            // CkPrintf("  Compute Interactions\n");
            profile.stepStartTime = CkWallTimer();
#ifdef ENABLE_BINNING
            locationsArray.BinVisits();
#else
            locationsArray.QueueVisits();
#endif

            if (scenario->numDaysToSeedOutbreak > day) {
              SeedInfections();
            }

            CkStartQD(CkCallback(
              CkIndex_Main::ComputedInteractions(),
              mainProxy
            ));
          }
        }
        when ComputedInteractions() {
          serial {
            double diff = CkWallTimer() - profile.stepStartTime;
            CkPrintf("  Interaction messages took %fs\n",
              diff);
            profile.interactionsTime += diff;

            // CkPrintf("  End of day state update starting\n");
            profile.stepStartTime = CkWallTimer();
            peopleArray.EndOfDayStateUpdate();
          }
        }
        when ReceiveInfectiousCount(Id infectiousCount) {
          serial {
            double diff = CkWallTimer() - profile.stepStartTime;
            CkPrintf("  End of day state update and reduction took %fs\n",
              diff);
            profile.eodTime += diff;

            // Use this count as desired here
            lastInfectiousCount = infectiousCount;
            if (scenario->hasInterventions()) {
              globScenario.ApplyInterventions(day, infectiousCount);
            }

            // Print how long this iteration took to run
            CkPrintf(
              "Iteration %d Execution Time: %lf seconds. Infectious Count: "
              ID_PRINT_TYPE ".\n",
              day, CkWallTimer() - profile.iterationStartTime, infectiousCount
            );

            // Trigger intervention updates.
            if (scenario->hasInterventions()) {
              globScenario.ApplyInterventions(day, infectiousCount);
            }
          }
        }

#ifdef ENABLE_LB
        // Turn off instrumentation before we start load balancing
        serial{traceArray.instrumentOff();}
        when instrumentSwitchOff() {}

        if (SHOULD_LB(day)) {
          serial {
            locationsArray.AtSync();
            peopleArray.AtSync();
          }

          // We don't want to continue until load balancing is complete for
          // *both* locations and people chares
          when locationsLBComplete() {
            when peopleLBComplete() {}
          }
        }
#endif // ENABLE_LB

#ifdef ENABLE_TRACING
        if (day == PROFILING_END_DAY) {
          serial{traceArray.traceOff();}
          when traceSwitchOff(){}

#if ENABLE_TRACING == TRACE_MEMORY
          serial{traceArray.reportMemoryUsage();}
          when printMemoryUsage(long usage) {
            serial {
              CkPrintf("Currently using %ld kb in total\n", usage);
            }
          }
#endif
        }
#endif // ENABLE_TRACING
      }
      serial {
        CkPrintf("Finished simulating %d days in %lf seconds.\n",
          day, (CkWallTimer() - profile.simulationStartTime));
#ifdef ENABLE_DEBUG
        if (ENABLE_DEBUG >= DEBUG_VERBOSE) {
          CkPrintf("  Processed " COUNTER_PRINT_TYPE " visits, "
            COUNTER_PRINT_TYPE " interactions, and "
            COUNTER_PRINT_TYPE " exposures, "
            COUNTER_PRINT_TYPE " total exposure duration\n",
            profile.totalVisits, profile.totalInteractions,
            profile.totalExposures, profile.totalExposureDuration);
        }
#endif
        CkPrintf("  Visit messages took %lf seconds\n",
          profile.visitsTime);
        CkPrintf("  Interaction calculations and messages took %lf seconds\n",
          profile.interactionsTime);
        CkPrintf("  End of day update and reduction took %lf seconds\n",
          profile.eodTime);

        peopleArray.SendStats();
      }
      when ReceiveStats(CkReductionMsg *summary) {
        serial {
          Id *data = reinterpret_cast<Id *>(summary->getData());
          SaveStats(data);
        }
      }
      serial {
        CkExit();
      }
    };

    entry void StartupComplete();
    entry void SeedInfections();
    entry void StartComputingInteractions();
    entry void ComputedInteractions();
#if ENABLE_DEBUG >= DEBUG_VERBOSE
    entry [reductiontarget] void ReceiveVisitsLoadedCount(Id visitsCount) {
      serial{CkPrintf("  Loaded a total of " ID_PRINT_TYPE " visits\n", visitsCount);}
    };
    entry [reductiontarget] void ReceiveVisitsSentCount(Counter count) {
      serial{
        profile.totalVisits += count;
        CkPrintf("  Processed " COUNTER_PRINT_TYPE " sent visits\n", count);
      }
    };
    entry [reductiontarget] void ReceiveInteractionsCount(Counter count) {
      serial{
        profile.totalInteractions += count;
        CkPrintf("  Processed " COUNTER_PRINT_TYPE " interactions\n", count);
      }
    };
    entry [reductiontarget] void ReceiveExposuresCount(Counter count) {
      serial{
        profile.totalExposures += count;
        CkPrintf("  Processed " COUNTER_PRINT_TYPE " exposures\n", count);
      }
    };
    entry [reductiontarget] void ReceiveExposureDuration(Counter duration) {
      serial{
        profile.totalExposureDuration += duration;
        CkPrintf("  " COUNTER_PRINT_TYPE "s total exposure\n", duration);
      }
    };
#endif // ENABLE_DEBUG
    entry [reductiontarget] void ReceiveInfectiousCount(Id infectiousCount);
    entry [reductiontarget] void ReceiveStats(CkReductionMsg *summary);
#ifdef ENABLE_TRACING
    entry [reductiontarget] void traceSwitchOn();
    entry [reductiontarget] void traceSwitchOff();
#if ENABLE_TRACING == TRACE_MEMORY
    entry [reductiontarget] void printMemoryUsage(long usage);
#endif
#endif // ENABLE_TRACING
#ifdef ENABLE_LB
    entry [reductiontarget] void instrumentSwitchOn();
    entry [reductiontarget] void instrumentSwitchOff();
    entry [reductiontarget] void locationsLBComplete();
    entry [reductiontarget] void peopleLBComplete();
#endif // ENABLE_LB
  };

  group TraceSwitcher{
    entry TraceSwitcher();
#ifdef ENABLE_TRACING
    entry void traceOn();
    entry void traceOff();
    entry void traceFlush();
#if ENABLE_TRACING == TRACE_MEMORY
    entry void reportMemoryUsage();
#endif
#endif // ENABLE_TRACING
#ifdef ENABLE_LB
    entry void instrumentOn();
    entry void instrumentOff();
#endif // ENABLE_LB
  };

#ifdef USE_HYPERCOMM
  group Aggregator {
    entry Aggregator(AggregatorParam p1, AggregatorParam p2);
  };
#endif // USE_HYPERCOMM

  array [1D] People {
    entry People(int seed, std::string scenarioPath);
    entry void SendVisitSchedules();
    entry void ReceiveExpectedVisitors(ExpectedVisitorsMessage msg);
    entry void SendVisitorStates();
    entry void SendVisitMessages(); // calls ReceiveVisitMessages
    entry AGGREGATE void ReceiveInteractions(InteractionMessage);
    entry void EndOfDayStateUpdate(); // contribute call to ReceiveInfectiousCount
    entry void SendStats(); // contribute call to ReceiveStats
    entry void ReceiveIntervention(int interventionIdx);
    //entry void TestCall(std::function<int(int)> func);
    entry void AtSync();
  };

  array [1D] Locations {
    entry Locations(int seed, std::string scenarioPath);
    entry void ReceiveVisitSchedule(VisitScheduleMessage msg);
    entry void SendExpectedVisitors();
    entry void ReceiveVisitorStates(PersonStatesMessage msg);
    entry void BinVisits();
    entry void QueueVisits();
    entry AGGREGATE void ReceiveVisitMessages(VisitMessage);
    entry void ComputeInteractions(); // calls ReceiveInteractions
    entry void ReceiveIntervention(int interventionIdx);
    entry void AtSync();
  };

  nodegroup Scenario {
    entry Scenario(Arguments args);
    entry void ApplyInterventions(int day, Id newDailyInfections);
  };

#ifdef USE_HYPERCOMM
  namespace aggregation {
    initproc void initialize(void);
  }
#endif // USE_HYPERCOMM
};
